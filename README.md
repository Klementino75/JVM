### Домашнее задание.

#### 4.1. JVM. Организация памяти, сборщики мусора, VisualVM.

Задание 1.

##### **Понимание JVM.**

При запуске *JvmComprehension* **JVM** загружает в память необходимые *классы*, проверяет *байткод*, выделяет необходимые *ресурсы* и выполняет *код*, преобразуя байткод в инструкции машинного языка, понятные конечной машине.

Загрузка классов происходит через подсистему *ClassLoader*.

1. Запроса на загрузку классов поступает в *Application ClassLoader*, который его делегтруе в *Platform ClassLoader*, который в свою очередь делегтрует его в *Bootstrap ClassLoader*.
2. В *Bootstrap ClassLoader* происходит поиск и загузка основных библиотек  **Java**, расположенных в java.base модуле, необходимых для старта **JVM**. Класс *JvmComprehension* не найден, следовательно поиска передается в обратном порядке, в начале в *Platform ClassLoader*.
3. В *Platform ClassLoader* идет поиск и загрузка сторонних библиотек. Класс *JvmComprehension* не найден, следовательно поиск переходит в *Application ClassLoader*.
4. В *Application ClassLoader* **JVM** находит класс *JvmComprehension* и происходит загрузка информации о данном классе в область памяти *Metaspace*, где хранится информация о имени класса *JvmComprehension*, методах *main*, *printAll* и *переменных*.
5. **JVM** переходит на этап *Linking* (линковка), состоящий из трёх этапов:
   - *Verify* (верификация) - провека, что класс *JvmComprehension* не нарушает симантику **Java**.
   - *Prepare* (подготовка) - выделяется память под статические методы *main()* и *printAll()*.
   - *Resolve* (разрешение) - связывание сылок надругие классы. Их нет в *JvmComprehension* и **JVM** передает выполнение *Initialization* (инициализация).
6. *Initialization* выполняются *static* инициализаторы и инициализаторы *static* полей.
7. Вызов метода *main()*. В области памяти *Stack Memory* создается *frame-main*, после чего начинается построчное выполнеие метода.

// 1. В *Stack Memory* во *frame-main* выделяется область памяти под переменную int i = 1.

// 2. В области памяти *Heap* (куча) создается объект класса *Object*, а ссылка на объект присваивается переменной *o*, которая будет храниться в *Stack Memory* во *frame-main*.

// 3. В области памяти *Heap* создается экземпляр класса *Integer* со значением 2, а ссылка на него присваивается переменной *ii* Integer будет храниться в *Stack Memory* во *frame-main*.

// 4. Поисходит вызов метода *printAll()* с параметрами *o, i , ii* и в области памяти *Stack Memory* создаётся *frame-printAll*:
   - Передаем ссылку на объект *Object* из переменной *o*.
   - Создается новый экземпляр переменной *int i*.
   - Передаем ссылку на объект Integer из переменной *ii*.

// 5. В области памяти *Heap* создается экземпляр класса *Integer* со значением 700, а ссылка на него присваивается переменной *uselessVar* Integer будет храниться в *Stack Memory* во *frame-printAll*.

// 6. Обращаемся к статическому полю *out* класса *System*, у которого вызываем метод *println()* и в качестве аргумента передаем объект класса *String*. В области памяти *Stack Memory* создаётся *frame-println* с параметрами *o.toString() + i + ii*:
   - Вызывается метод класса *Object* через ссылку *o.toString()* и в области памяти *Stack Memory* создаётся *frame-toString* объекта *Object*. **JVM** выполняет метод *toString()*, после выполнения метода *frame-toString()* автоматически удаляется и выполнение переходит к ваполнению метода *println()*. После его выполнения *frame-println*, все ссылки и экземпляры переменной автоматически удаляются из *Stack Memory*. Если будет вызван *Сборщик мусора*, то объект класса *Integer* с ссылкой *uselessVar* будет удалён из *Stack Memory*, как и сам объект из *Heap*.
   - Создается новый экземпляр переменной *int i* со значением в *frame-println*.
   - Передаем ссылку на объект *Integer* из *frame-println*.

// 7. В области памяти *Stack Memory* создаётся *frame-println* метода *println()*, которому в качестве аргумента передается ссыка на константу объект типа *String* со значением *"finished"* из области памяти *Heap*. После выполнения метода *println()*: *frame-println*, все ссылки и экземпляры переменной автоматически удаляются, из *Stack Memory*. Если будет вызван *Сборщик мусора*, то объект *String* со значением *"finished"* удаляется из *Heap*. Метод *main()* выполняется и его *frame-main* удаляется из *Stack Memory* и вся программа завершается. Сборщик мусора всё удаляет из *Heap* и область памяти *Metaspace* очищается.